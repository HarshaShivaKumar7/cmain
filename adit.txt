--13
#include<stdlib.h> 
#include<GL/glut.h> 
GLfloatver[][3]={ { -1,-1,-1 },{ 1,-1,-1 },{ 1,1,-1 },{ -1,1,-1 },{ -1,-1,1 },{ 1,-1,1 },{ 1,1,1 },{ 1,1,1} }; 
GLfloatcol[][3] = { { 0,0,0 },{ 1,0,0 },{ 1,1,0 },{ 0,1,0 },{ 0,0,1 },{ 1,0,1 },{ 1,1,1 },{ 0,1,1 } }; 
void polygon(int a, int b, int c, int d) {

glBegin(GL_POLYGON);
glColor3fv(col[a]);
glVertex3fv(ver[a]);
glColor3fv(col[b]);
glVertex3fv(ver[b]);
glColor3fv(col[c]);
glVertex3fv(ver[c]);
glColor3fv(col[d]);
glVertex3fv(ver[d]);
glEnd();
}
voidcolorCube(void) {
  polygon(0, 3, 2, 1);
  polygon(2, 3, 7, 6);
  polygon(0, 4, 7, 3);
  polygon(1, 2, 6, 5);
  polygon(4, 5, 6, 7);
  polygon(0, 1, 5, 4);
}
staticGLfloatth[] = {
  0,
  0,
  0
};
staticGLint axis = 0;
void display(void) {
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glLoadIdentity();
  glRotatef(th[0], 1, 0, 0);
  glRotatef(th[1], 0, 1, 0);
  glRotatef(th[2], 0, 0, 1);
  colorCube();
  glFlush();
  glutSwapBuffers();
  20
}
voidspinCube() {
  th[axis] = th[axis] + 10;
  if (th[axis] > 360) th[axis] = th[axis] - 360;
  glutPostRedisplay();
}
voidmouse(intbtn, intstate, intx, inty) {
  if (btn == GLUT_LEFT_BUTTON && state == GLUT_DOWN) axis = 0;
  if (btn == GLUT_MIDDLE_BUTTON && state == GLUT_DOWN) axis = 1;
  if (btn == GLUT_RIGHT_BUTTON && state == GLUT_DOWN) axis = 2;
}
voidmyReshape(intw, inth) {
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(-2, 2, -2, 2, -10, 10);
  glMatrixMode(GL_MODELVIEW);
}
voidmain(intargc, char ** argv) {
  glutInit( & argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutCreateWindow("colorCube");
  glutInitWindowSize(700, 700);
  glutReshapeFunc(myReshape);
  glutDisplayFunc(display);
  glutIdleFunc(spinCube);
  glutMouseFunc(mouse);
  glEnable(GL_DEPTH_TEST);
  glutMainLoop();
}
--14
#include<stdlib.h>
#include<GL/glut.h>
GLfloat vertices[][3] = { { -1.0,-1.0,-1.0 },{ 1.0,-1.0,-1.0 }, { 1.0,1.0,-1.0 },{ -1.0,1.0,-1.0 }, { -1.0,-1.0,1.0 }, { 1.0,-1.0,1.0 },{ 1.0,1.0,1.0 },{ -1.0,1.0,1.0 } };

GLfloat colors[][3] = {
  {0.0,0.0,0.0},{1.0,0.0,0.0},{1.0,1.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0},{1.0,0.0,1.0},{1.0,1.0,1.0},{0.0,1.0,1.0}
};
void quad(int a, int b, int c, int d) {
  glBegin(GL_POLYGON);
  glColor3fv(colors[a]);
  glVertex3fv(vertices[a]);
  glColor3fv(colors[b]);
  glVertex3fv(vertices[b]);
  glColor3fv(colors[c]);
  glVertex3fv(vertices[c]);
  glColor3fv(colors[d]);
  glVertex3fv(vertices[d]);
  glEnd();
}
void colorcube() {
  quad(0, 3, 2, 1);
  quad(2, 3, 7, 6);
  quad(0, 4, 7, 3);
  quad(1, 2, 6, 5);
  quad(4, 5, 6, 7);
  quad(0, 1, 5, 4);
}
staticGL float theta[] = {
  0.0,
  0.0,
  0.0
};
static GLint axis = 2;
static GLdouble viewer[] = {
  0.0,
  0.0,
  5.0
};
void display(void) {
  glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
  glLoadIdentity();
  gluLookAt(viewer[0], viewer[1], viewer[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
  glRotatef(theta[0], 1.0, 0.0, 0.0);
  glRotatef(theta[1], 0.0, 1.0, 0.0);
  glRotatef(theta[2], 0.0, 0.0, 1.0);
  colorcube();
  glFlush();
  glutSwapBuffers();
}
void mouse(int btn, int state, int x, int y) {
  if (btn == GLUT_LEFT_BUTTON && state == GLUT_DOWN) axis = 0;
  if (btn == GLUT_MIDDLE_BUTTON && state == GLUT_DOWN) axis = 1;
  if (btn == GLUT_RIGHT_BUTTON && state == GLUT_DOWN) axis = 2;
  theta[axis] += 2.0;
  if (theta[axis] > 360.0) theta[axis] -= 360.0;
  display();
}
void keys(unsigned char key, int x, int y) {
  if (key == 'x') viewer[0] -= 1.0;
  if (key == 'X') viewer[0] += 1.0;
  if (key == 'y') viewer[1] -= 1.0;
  if (key == 'Y') viewer[1] += 1.0;
  if (key == 'z') viewer[2] -= 1.0;
  if (key == 'Z') viewer[2] += 1.0;
  display();
}
void myReshape(int w, int h) {
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  if (w <= h) {
    glFrustum(-2.0, 2.0, -2.0 * (GLfloat) h / (GLfloat) w, 2.0 * (GLfloat) h / (GLfloat) w,
      2.0, 20.0);
  } else {
    glFrustum(-2.0, 2.0, -2.0 * (GLfloat) w / (GLfloat) h, 2.0 * (GLfloat) w / (GLfloat) h,
      2.0, 20.0);
  }
  glMatrixMode(GL_MODELVIEW);
}
void main(int argc, char ** argv) {
  glutInit( & argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutInitWindowSize(500, 500);
  glutCreateWindow("Colorcube Viewer");
  glutReshapeFunc(myReshape);
  glutDisplayFunc(display);
  glutMouseFunc(mouse);
  glutKeyboardFunc(keys);
  glEnable(GL_DEPTH_TEST);
  glutMainLoop();
}

--17
#include<stdio.h>
#include<GL/glut.h>
typedef float point[3];
pointv[] = { { 0,0,1 },{ 0,1,-1 },{ -1,-1,-1 },{ 1,-1,-1 } };
int n;
void triangle(point a, point b, point c) {
	glBegin(GL_POLYGON);
	glVertex3fv(a);
	glVertex3fv(b);
	glVertex3fv(c);
	glEnd();
}
void divTri(point a, point b, point c, int m) {
	point v1, v2, v3;
	int j;
	if (m>0) {
		for (j = 0; j<3; j++)
			v1[j] = (a[j] + b[j]) / 2;
		for (j = 0; j<3; j++)
			v2[j] = (a[j] + c[j]) / 2;
		for (j = 0; j<3; j++)
			v3[j] = (c[j] + b[j]) / 2;
		divTri(a, v1, v2, m - 1);
		divTri(c, v2, v3, m - 1);
		divTri(b, v3, v1, m - 1);
	}
	else(triangle(a, b, c));
}
void tetra(int m)
{
	glColor3f(1, 0, 0);
	divTri(v[0], v[1], v[2], m);
	glColor3f(0, 1, 0);
	divTri(v[3], v[2], v[1], m);
	glColor3f(0, 0, 1);
	divTri(v[0], v[3], v[1], m);
	glColor3f(0, 0, 0);
	divTri(v[0], v[2], v[3], m);
}
void display(void)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glLoadIdentity();
	tetra(n);
	glFlush();
}
voidmyReshape(int w, int h)
{
	glViewport(0, 0, w, h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	if (w<= h)
	glOrtho(-2, 2, -2 * (GLfloat)h / (GLfloat)w,
	2 * (GLfloat)h / (GLfloat)w, -10, 10);
	else
	glOrtho(-2 * (GLfloat)w / (GLfloat)h,
	2 * (GLfloat)w / (GLfloat)h, -2, 2, -10, 10);
	glMatrixMode(GL_MODELVIEW);
	glutPostRedisplay();
}
void main(int argc, char **argv) {
	printf("Enter number of division:");
	scanf_s("%d", &n); glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH); glutInitWindowSize(640, 840);
	glutCreateWindow("3D gasket");
	glutReshapeFunc(myReshape);
	glutDisplayFunc(display);
	glEnable(GL_DEPTH_TEST);
	glClearColor(1, 1, 1, 1);
	glutMainLoop();
}
